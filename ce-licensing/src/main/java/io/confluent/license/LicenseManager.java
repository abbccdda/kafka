/*
 * Copyright [2017  - 2017] Confluent Inc.
 */

package io.confluent.license;

import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.common.errors.ClusterAuthorizationException;
import org.apache.kafka.common.errors.TimeoutException;
import org.apache.kafka.common.errors.UnsupportedVersionException;
import org.apache.kafka.common.utils.Time;
import org.jose4j.jwa.AlgorithmConstraints;
import org.jose4j.jws.AlgorithmIdentifiers;
import org.jose4j.jws.JsonWebSignature;
import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.InvalidJwtException;
import org.jose4j.jwt.consumer.InvalidJwtSignatureException;
import org.jose4j.lang.JoseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;

import io.confluent.license.util.StringUtils;

/**
 * A license manager that can validate and store Confluent licenses in a topic in one Kafka cluster.
 *
 * <p>This manager is supplied configurations for an admin client to create the topic if necessary,
 * a consumer to read the contents of that topic, and a producer to store the updated license
 * information, if such is supplied when
 * {@link #registerOrValidateLicense(String) registering and validating} licenses.
 * Additional admin client configurations can be provided for {@em other} Kafka clusters
 * that the license manager should consider when validating a license.
 *
 * <h2>Types of Licenses</h2>
 * This license manager deal with three types of licenses:
 * <ol>
 *   <li><b>Enterprise License</b> is a license that is generated by Confluent for enterprise
 *   customers, and which expires after a specfied period of time. Customers can renew their
 *   license, and the new license should be stored in the topic, either by updating a component
 *   with that license or by directly writing it.</li>
 *   <li><b>30 Day Trial License</b> allows users to download and evaluate Confluent products by
 *   for up to 30 days before the license expires and the components stop working.
 *   </li>
 *   <li><b>Free Forever Single Node Cluster License</b> allows users to download and evaluate
 *   Confluent products for an unlimited time as long as they run at most one broker in their
 *   Kafka clusters. This type of license only applies if there is not already another type of
 *   license stored in the topic (even if expired), and is considered valid only when the
 *   clusters have only one broker.
 *   </li>
 * </ol>
 *
 * <h2>Usage</h2>
 * To use the LicenseManager, instantiate it with the correct configurations for the primary
 * Kafka cluster where the license topic exists. If the licensed component uses more than one
 * Kafka cluster, also supply admin client configurations for the additional cluster(s) so that
 * the license manager can ensure that the restrictions of the Free Forever license are followed,
 * if that license is used.
 *
 * <p>The next step is to read the license information from the component's configuration, or use a
 * blank string if the user did not provide a license, and call
 * {@link #registerOrValidateLicense(String)} to register the new license or, if it is
 * blank, attempt to read a previously-stored license.
 * This method will thrown an {@link InvalidLicenseException} if the license is not valid or has
 * expired. Otherwise, a valid license exists and is returned for use by the application.
 *
 * <p>Note that the {@link #registerOrValidateLicense(String)} logs information about the license,
 * either at WARN level if the license expires within 10 days, or at INFO level otherwise. The
 * message includes the type of license, the number of days until the license expires, and the
 * expiration date.
 *
 * <p>Finally, when the application stops, call {@link #stop()} so the LicenseManager can release
 * any resources it might have created.
 *
 * <p>Here is an example:
 * <pre>
 *   // Read the license string from the application or component's configuration
 *   String licenseStr = ...
 *
 *   // Start the license manager
 *   String topicName = ...
 *   Map&lt;String, Object> producerConfig = ...
 *   Map&lt;String, Object> consumerConfig = ...
 *   Map&lt;String, Object> adminConfig = ...
 *
 *   LicenseManager licenseMgr = new LicenseManager(
 *       producerConfig,
 *       consumerConfig,
 *       adminConfig);
 *   License license = licenseMgr.registerOrValidateLicense(licenseStr);
 *
 *   // At some point stop the license manager
 *   licenseMgr.stop();
 * </pre>
 */
public class LicenseManager {

  private static final Logger log = LoggerFactory.getLogger(LicenseManager.class);
  protected static final long WARN_THRESHOLD_DAYS = 10;

  private final LicenseStore licenseStore;
  private final Time time;
  private final ClusterClient primaryClusterClient;
  private final Map<String, ClusterClient> clusterClients = new ConcurrentHashMap<>();
  private final CopyOnWriteArrayList<Consumer<LicenseChanged>> listeners =
      new CopyOnWriteArrayList<>();

  /**
   * Create a new license manager that uses the specified topic for licenses, configurations for an
   * admin client, producer, and consumer to create, write to, and read from that topic in a
   * primary Kafka cluster.
   *
   * @param topic the name of the topic where licenses are persisted; may not be null
   * @param producerConfig the configuration for the producer used to write to the license topic;
   *                       may not be null
   * @param consumerConfig the configuration for the consumer used to read from the license topic;
   *                       may not be null
   * @param topicConfig the configuration for the admin client to create the license topic if
   *                    required; may not be null
   */
  public LicenseManager(
      String topic,
      Map<String, Object> producerConfig,
      Map<String, Object> consumerConfig,
      Map<String, Object> topicConfig
  ) {
    this(
        new BasicClusterClient(topicConfig),
        new LicenseStore(topic, producerConfig, consumerConfig, topicConfig),
        Time.SYSTEM
    );
  }

  //visible for testing
  protected LicenseManager(
      ClusterClient primaryClusterClient,
      LicenseStore licenseStore,
      Time time
  ) {
    this.licenseStore = licenseStore;
    this.time = time;
    this.licenseStore.start();
    this.primaryClusterClient = primaryClusterClient;
  }

  /**
   * Add another Kafka cluster to be considered when validating a license. The cluster is
   * defined with the {@link AdminClientConfig} for the cluster, and the principal requires
   * privilege to read the cluster metadata.
   *
   * <p>This method is safe to be called whether or not the license manager is
   * {@link #start() running}.
   *
   * @param adminConfig the admin client configurations for another Kafka clusters that should be
   *                   considered during license validation; may be null or empty
   */
  public void addCluster(String key, Map<String, Object> adminConfig) {
    if (adminConfig != null && !adminConfig.isEmpty()) {
      addCluster(key, new BasicClusterClient(adminConfig));
    }
  }

  /**
   * Add another Kafka cluster to be considered when validating a license. The cluster is
   * defined with the supplied {@link ClusterClient} function, allowing callers to fully control
   * how the license manager determines the size of a cluster.
   *
   * <p>This method is safe to be called whether or not the license manager is
   * {@link #start() running}.
   *
   * @param key the unique key for the cluster client; may not be null
   * @param client the cluster client function that should be used to determine the size of a
   *               cluster during license validation; may be null or empty
   */
  public void addCluster(String key, ClusterClient client) {
    Objects.nonNull(key);
    Objects.nonNull(client);
    clusterClients.put(key, client);
  }

  /**
   * Remove the Kafka cluster client with the specific name from being considered when validating a
   * license.
   *
   * <p>This method is safe to be called whether or not the license manager is
   * {@link #start() running}.
   *
   * @return true if the admin config was removed, or false otherwise
   */
  public boolean removeCluster(String key) {
    return key != null && clusterClients.remove(key) != null;
  }

  /**
   * Add a listener for subsequent license changes.
   *
   * @param listener the function that is to be called when license changes are detected
   * @return true if the listener was added, or false if the listener was null or was already a
   *         listener
   * @see #removeListener(Consumer)
   */
  public boolean addListener(Consumer<LicenseChanged> listener) {
    return listener != null && listeners.addIfAbsent(listener);
  }

  /**
   * Remove a previously registered license change listener.
   *
   * @param listener the function that is no longer to be called when license changes are detected
   * @return true if the listener was removed, or false if the listener was not previously
   *         {@link #addListener(Consumer) registered}
   * @see #addListener(Consumer)
   */
  public boolean removeListener(Consumer<LicenseChanged> listener) {
    return listener != null && listeners.remove(listener);
  }

  /**
   * Begin running this license manager's check on a daily schedule, or more frequently if the
   * license is expired or has less than 1 day remaining. The first check will be scheduled for
   * 24 hours after this method is called, since the calling application is expected to explicitly
   * check the license once upon startup before this method is called.
   *
   * <p>This is useful for automatically detecting changes in the license and notifying the
   * {@link #addListener(Consumer) listeners}.
   *
   * @see #addListener(Consumer)
   * @see #removeListener(Consumer)
   */
  public void start() {
    LicenseManagers.INSTANCE.start(this); // safe even if already started
  }

  /**
   * Stop this license manager, close any resources, and remove any scheduled license checks.
   * It is safe to call this method if this license manager was not {@link #start() started}.
   *
   * @see #start()
   */
  public void stop() {
    // safe even if not already started
    if (!LicenseManagers.INSTANCE.stop(this)) {
      // Was not registered, so stop the store ourselves
      doStop();
    }
  }

  protected void doStart() {
    licenseStore.start();
  }

  protected void doStop() {
    licenseStore.stop();
  }

  /**
   * Validate the supplied license, or if blank register a new trial license. This should be
   * called with the valid license before calling {@link #start()}.
   *
   * @param license the new license string to be persisted in the topic; may be empty if there is
   *                no updated license
   * @return the summary of the current license; never null
   * @throws InvalidLicenseException if the supplied license is not valid
   */
  public License registerOrValidateLicense(String license) throws InvalidLicenseException {
    PublicKey publicKey = loadPublicKey();
    License newLicense = null;

    // If a license key is given, always validate just against this key and fail if it's not valid
    if (StringUtils.isNotBlank(license)) {
      try {
        newLicense = readLicense(publicKey, license, false);
        log.debug("Found valid new license: {}", newLicense);
      } catch (InvalidLicenseException e) {
        throw new InvalidLicenseException("Supplied license is invalid: " + e.getMessage(), e);
      }
    }

    long now = time.milliseconds();
    String reason = "";
    String storedLicenseStr = licenseStore.licenseScan();
    License storedLicense = null;
    if (StringUtils.isNotBlank(storedLicenseStr)) {
      // First check whether the stored license is even valid and has an expiration
      try {
        storedLicense = readLicense(publicKey, storedLicenseStr, true);
        License.expiration(storedLicense.jwtClaims());
      } catch (Throwable t) {
        if (newLicense != null) {
          reason = "New license replaces invalid stored license (" + t.getMessage() + ").";
        } else {
          throw new InvalidLicenseException("Stored license is invalid", t);
        }
        storedLicense = null;
      }
    }
    if (newLicense != null) {
      // Get expiration of given valid license.
      try {
        License.expiration(newLicense.jwtClaims());
      } catch (Throwable t) {
        if (storedLicense != null) {
          newLicense = storedLicense;
          reason = "Using stored license because new license has an invalid expiration.";
          log.warn(reason, t);
        } else {
          throw new InvalidLicenseException(
              "No stored license, and error extracting expiration date from valid license",
              t
          );
        }
      }
    }

    License latestLicense;
    if (storedLicense == null) {
      // There was no valid stored license (trial or otherwise)
      if (newLicense == null) {
        // There also was no new license either, so generate a new trial or free-tier license
        newLicense = generateLicense(publicKey, now);
      }
      if (!newLicense.isFreeTier()) {
        // Store the generated license except if it is a free tier license
        log.debug("Storing license: {}", newLicense);
        licenseStore.registerLicense(newLicense.serializedForm());
      }
      latestLicense = newLicense;
    } else {
      latestLicense = storedLicense;
      if (storedLicense.expiresBefore(newLicense) && !newLicense.isFreeTier()) {
        // Store the new license
        log.debug("Storing updated license with later expiration: {}", newLicense);
        licenseStore.registerLicense(newLicense.serializedForm());
        latestLicense = newLicense;
      }
    }

    assert latestLicense != null;
    checkLicense(latestLicense, storedLicense, now, reason);
    return latestLicense;
  }

  protected License readLicense(PublicKey publicKey, String licenseStr, boolean stored)
      throws InvalidLicenseException {
    License result;
    try {
      JwtClaims givenJwtClaims;
      if (stored) {
        givenJwtClaims = License.verifyStored(publicKey, licenseStr);
      } else {
        givenJwtClaims = License.verify(publicKey, licenseStr);
      }
      result = new License(givenJwtClaims, time, licenseStr);
      return result;
    } catch (InvalidJwtSignatureException e) {
      throw new InvalidLicenseException("Invalid signature", e);
    } catch (InvalidJwtException e) {
      throw new InvalidLicenseException("License does not match expected form", e);
    } catch (Throwable e) {
      throw new InvalidLicenseException("Invalid license with invalid expiration", e);
    }
  }

  protected License generateLicense(PublicKey publicKey, long now)
      throws InvalidLicenseException {
    // No license supplied
    if (hasOnlySingleNodeClusters()) {
      // Return a non-persistent Free-Forever license
      JwtClaims jwtClaims = License.baseClaims(
          "free tier",
          Long.MAX_VALUE,
          true
      );
      jwtClaims.setClaim(License.TYPE_CLAIM_NAME, "free");
      String generatedLicense = generateFreeLicense(jwtClaims);
      License license = new License(jwtClaims, time, generatedLicense);
      log.debug("All single-node cluster checks satisfied; using {}", license);
      return license;
    }

    // Starting trial period.
    // Expiration is rounded to seconds during the construction of baseClaims, thus add a sec
    JwtClaims trialClaims = License.baseClaims(
        "trial",
        now + TimeUnit.DAYS.toMillis(30) + 1000,
        true
    );
    trialClaims.setClaim(License.TYPE_CLAIM_NAME, "trial");
    String generatedLicense = License.generateTrialLicense(trialClaims);
    License license = new License(trialClaims, time, generatedLicense);
    log.debug("Creating new {}", license);
    return license;
  }

  private void checkLicense(
      License newLicense,
      License oldLicense,
      long now,
      String reason
  ) throws InvalidLicenseException {
    if (newLicense.isFreeTier()) {
      reason = "License for single cluster, single node";
      log.info(reason);
      notifyLicense(newLicense, oldLicense, reason);
    } else if (now > newLicense.expirationMillis()) {
      String msg = newLicense.toString();
      if (StringUtils.isBlank(reason)) {
        reason = msg;
      }
      notifyLicense(newLicense, null, reason);
      throw new InvalidLicenseException(msg);
    } else if (newLicense.expirationMillis() < Long.MAX_VALUE) {
      // License is still valid but limited
      String msg = newLicense.toString();
      if (newLicense.timeRemaining(TimeUnit.DAYS) < WARN_THRESHOLD_DAYS) {
        log.warn(msg);
      } else {
        log.info(msg);
      }
      if (StringUtils.isBlank(reason)) {
        reason = msg;
      } else {
        reason = reason + " " + msg;
      }
      notifyLicense(newLicense, oldLicense, reason);
    }
  }

  protected boolean hasOnlySingleNodeClusters() {
    return primaryClusterClient != null
           && primaryClusterClient.brokerCount() == 1
           && clusterClients.values().stream().allMatch(client -> client.brokerCount() == 1);
  }

  protected void notifyLicense(
      License newLicense,
      License oldLicense,
      String reason
  ) {
    if (newLicense.isEquivalentTo(oldLicense)) {
      log.debug(
          "Skipping notifying {} listeners of unchanged license: {}",
          listeners.size(),
          newLicense
      );
      return;
    }
    // Determine the type of license change
    LicenseChanged.Type changeType = LicenseChanged.Type.UPDATED;
    if (newLicense.isExpired()) {
      changeType = LicenseChanged.Type.EXPIRED;
    } else if (newLicense.isRenewalOf(oldLicense)) {
      changeType = LicenseChanged.Type.RENEWAL;
    }
    LicenseChangedEvent event = new LicenseChangedEvent(newLicense, changeType, reason);
    log.debug("Notifying {} listeners of license change: {}", listeners.size(), event);
    for (Consumer<LicenseChanged> listener : listeners) {
      try {
        listener.accept(event);
      } catch (Throwable t) {
        log.error("Unexpected error when calling license manager listener:", t);
      }
    }
  }

  public static PublicKey loadPublicKey() {
    try {
      return License.loadPublicKey();
    } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {
      // This can happen for two reasons:
      //  1. The public key was not packaged with the jar.
      //  2. The public key which was packaged was corrupt.
      throw new IllegalStateException("Internal license validation error", e);
    }
  }

  private static String generateFreeLicense(JwtClaims claims) throws InvalidLicenseException {
    JsonWebSignature jws = new JsonWebSignature();
    jws.setAlgorithmConstraints(AlgorithmConstraints.NO_CONSTRAINTS);
    jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.NONE);
    jws.setPayload(claims.toJson());
    try {
      return jws.getCompactSerialization();
    } catch (JoseException e) {
      log.error("Error while attempting to start free tier: ", e);
      throw new InvalidLicenseException(
          "Error creating license for trial version: ", e
      );
    }

  }

  protected static class LicenseChangedEvent implements LicenseChanged {

    private final License license;
    private final Type type;
    private final String description;

    LicenseChangedEvent(License license, Type type, String description) {
      Objects.nonNull(license);
      Objects.nonNull(type);
      Objects.nonNull(description);
      this.license = license;
      this.type = type;
      this.description = description;
    }

    @Override
    public License license() {
      return license;
    }

    @Override
    public Type type() {
      return type;
    }

    @Override
    public String description() {
      return description;
    }

    @Override
    public int hashCode() {
      return type().hashCode();
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) {
        return true;
      }
      if (obj instanceof LicenseChangedEvent) {
        LicenseChangedEvent that = (LicenseChangedEvent) obj;
        return this.type() == that.type()
               && Objects.equals(this.license(), that.license());
      }
      return false;
    }

    @Override
    public String toString() {
      return type + " " + license + " (" + description + ")";
    }
  }

  @FunctionalInterface
  protected interface ClusterClient {
    int brokerCount();
  }

  protected static class BasicClusterClient implements ClusterClient {

    private final Map<String, Object> adminConfig;

    BasicClusterClient(Map<String, Object> adminConfig) {
      this.adminConfig = new HashMap<>(adminConfig);
    }

    public int brokerCount() {
      try (AdminClient admin = AdminClient.create(adminConfig)) {
        int count = admin.describeCluster().nodes().get().size();
        log.debug("Found {} brokers in Kafka cluster at {}", count, this);
        return count;
      } catch (ExecutionException e) {
        Throwable cause = e.getCause();
        if (cause instanceof UnsupportedVersionException) {
          log.debug("Unable to use admin client to connect to older Kafka cluster at {}", this);
          return -2;
        }
        if (cause instanceof ClusterAuthorizationException) {
          log.debug("Not authorized to use admin client to connect to Kafka cluster at {}", this);
          return -3;
        }
        if (cause instanceof TimeoutException) {
          log.debug("Timed out waiting to connect to Kafka cluster at {}", this);
          return -4;
        }
      } catch (InterruptedException e) {
        Thread.interrupted();
        return -5;
      }
      return -1;
    }

    @Override
    public String toString() {
      Object servers = adminConfig.get(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG);
      return servers == null ? "<unknown>" : servers.toString();
    }
  }
}

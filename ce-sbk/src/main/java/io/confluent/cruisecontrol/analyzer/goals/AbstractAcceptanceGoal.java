package io.confluent.cruisecontrol.analyzer.goals;

import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;
import com.linkedin.kafka.cruisecontrol.analyzer.OptimizationOptions;
import com.linkedin.kafka.cruisecontrol.analyzer.goals.AbstractGoal;
import com.linkedin.kafka.cruisecontrol.analyzer.goals.Goal;
import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;
import com.linkedin.kafka.cruisecontrol.model.Broker;
import com.linkedin.kafka.cruisecontrol.model.ClusterModel;
import com.linkedin.kafka.cruisecontrol.model.ClusterModelStats;
import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;
import java.util.Collections;
import java.util.Set;
import java.util.SortedSet;

/**
 * An abstract class for goals that only validates actions generated by other goals.
 * {@link AbstractGoal#actionAcceptance(BalancingAction, ClusterModel)} is the only
 * method that must be implemented.
 */
public abstract class AbstractAcceptanceGoal extends AbstractGoal {

    @Override
    public ClusterModelStatsComparator clusterModelStatsComparator() {
        return new AcceptanceGoalComparator();
    }

    /**
     * Return the model completeness requirements for this goal. Because it only evaluates other proposals, it
     * has no requirements
     *
     * @return ModelCompletenessRequirements object with minimal requirements
     */
    @Override
    public ModelCompletenessRequirements clusterModelCompletenessRequirements() {
        // This goal has the minimum data requirements, and doesn't require all topics
        return new ModelCompletenessRequirements(1, 0.0, false);
    }

    /**
     * Signal for finishing the process for rebalance or self-healing for this goal. It is intended to mark the goal
     * optimization as finished and perform the memory clean up after the goal optimization.
     */
    @Override
    public void finish() {
        _finished = true;
    }

    /**
     * True if this is a hard goal, false otherwise.
     */
    @Override
    public boolean isHardGoal() {
        return true;
    }

    /**
     * No brokers need to be balanced for this goal, because it only needs to validate moves proposed by other goals
     *
     * @param clusterModel The state of the cluster.
     * @return The brokers to be balanced, in this case the empty set
     */
    @Override
    protected SortedSet<Broker> brokersToBalance(ClusterModel clusterModel) {
        return Collections.emptySortedSet();
    }

    /**
     * This goal is always considered self-satisfied, since it can only be violated by other goals' actions
     *
     * @param clusterModel The state of the cluster.
     * @param action Action containing information about potential modification to the given cluster model.
     * @return true, because the goal is always self-satisfied
     */
    @Override
    protected boolean selfSatisfied(ClusterModel clusterModel, BalancingAction action) {
        return true;
    }

    /**
     * Initialize states that this goal requires -- e.g. run sanity checks regarding hard goals requirements.
     *
     * @param clusterModel        The state of the cluster.
     * @param optimizationOptions Options to take into account during optimization -- e.g. excluded topics.
     */
    @Override
    protected void initGoalState(ClusterModel clusterModel, OptimizationOptions optimizationOptions) throws OptimizationFailureException {

    }

    @Override
    protected void updateGoalState(ClusterModel clusterModel,
                                   Set<String> excludedTopics) throws OptimizationFailureException {
        finish();
    }

    /**
     * Rebalance the given broker without violating the constraints of the current goal and optimized goals.
     *
     * @param broker              Broker to be balanced.
     * @param clusterModel        The state of the cluster.
     * @param optimizedGoals      Optimized goals.
     * @param optimizationOptions Options to take into account during optimization -- e.g. excluded topics.
     */
    @Override
    protected void rebalanceForBroker(Broker broker,
                                      ClusterModel clusterModel,
                                      Set<Goal> optimizedGoals,
                                      OptimizationOptions optimizationOptions) throws OptimizationFailureException {

    }

    private static class AcceptanceGoalComparator implements ClusterModelStatsComparator {

        @Override
        public int compare(ClusterModelStats stats1, ClusterModelStats stats2) {
            // Stats are not relevant for this goal, because it will not propose actions of its own
            return 0;
        }

        @Override
        public String explainLastComparison() {
            return null;
        }
    }
}
